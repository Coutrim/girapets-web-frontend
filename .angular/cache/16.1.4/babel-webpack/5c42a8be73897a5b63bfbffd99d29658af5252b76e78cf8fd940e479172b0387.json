{"ast":null,"code":"class ObjectUtils {\n  static equals(obj1, obj2, field) {\n    if (field) return this.resolveFieldData(obj1, field) === this.resolveFieldData(obj2, field);else return this.equalsByValue(obj1, obj2);\n  }\n  static equalsByValue(obj1, obj2) {\n    if (obj1 === obj2) return true;\n    if (obj1 && obj2 && typeof obj1 == 'object' && typeof obj2 == 'object') {\n      var arrA = Array.isArray(obj1),\n        arrB = Array.isArray(obj2),\n        i,\n        length,\n        key;\n      if (arrA && arrB) {\n        length = obj1.length;\n        if (length != obj2.length) return false;\n        for (i = length; i-- !== 0;) if (!this.equalsByValue(obj1[i], obj2[i])) return false;\n        return true;\n      }\n      if (arrA != arrB) return false;\n      var dateA = obj1 instanceof Date,\n        dateB = obj2 instanceof Date;\n      if (dateA != dateB) return false;\n      if (dateA && dateB) return obj1.getTime() == obj2.getTime();\n      var regexpA = obj1 instanceof RegExp,\n        regexpB = obj2 instanceof RegExp;\n      if (regexpA != regexpB) return false;\n      if (regexpA && regexpB) return obj1.toString() == obj2.toString();\n      var keys = Object.keys(obj1);\n      length = keys.length;\n      if (length !== Object.keys(obj2).length) return false;\n      for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(obj2, keys[i])) return false;\n      for (i = length; i-- !== 0;) {\n        key = keys[i];\n        if (!this.equalsByValue(obj1[key], obj2[key])) return false;\n      }\n      return true;\n    }\n    return obj1 !== obj1 && obj2 !== obj2;\n  }\n  static resolveFieldData(data, field) {\n    if (data && field) {\n      if (this.isFunction(field)) {\n        return field(data);\n      } else if (field.indexOf('.') == -1) {\n        return data[field];\n      } else {\n        let fields = field.split('.');\n        let value = data;\n        for (let i = 0, len = fields.length; i < len; ++i) {\n          if (value == null) {\n            return null;\n          }\n          value = value[fields[i]];\n        }\n        return value;\n      }\n    } else {\n      return null;\n    }\n  }\n  static isFunction(obj) {\n    return !!(obj && obj.constructor && obj.call && obj.apply);\n  }\n  static reorderArray(value, from, to) {\n    let target;\n    if (value && from !== to) {\n      if (to >= value.length) {\n        to %= value.length;\n        from %= value.length;\n      }\n      value.splice(to, 0, value.splice(from, 1)[0]);\n    }\n  }\n  static generateSelectItems(val, field) {\n    let selectItems;\n    if (val && val.length) {\n      selectItems = [];\n      for (let item of val) {\n        selectItems.push({\n          label: this.resolveFieldData(item, field),\n          value: item\n        });\n      }\n    }\n    return selectItems;\n  }\n  static insertIntoOrderedArray(item, index, arr, sourceArr) {\n    if (arr.length > 0) {\n      let injected = false;\n      for (let i = 0; i < arr.length; i++) {\n        let currentItemIndex = this.findIndexInList(arr[i], sourceArr);\n        if (currentItemIndex > index) {\n          arr.splice(i, 0, item);\n          injected = true;\n          break;\n        }\n      }\n      if (!injected) {\n        arr.push(item);\n      }\n    } else {\n      arr.push(item);\n    }\n  }\n  static findIndexInList(item, list) {\n    let index = -1;\n    if (list) {\n      for (let i = 0; i < list.length; i++) {\n        if (list[i] == item) {\n          index = i;\n          break;\n        }\n      }\n    }\n    return index;\n  }\n  static removeAccents(str) {\n    if (str && str.search(/[\\xC0-\\xFF]/g) > -1) {\n      str = str.replace(/[\\xC0-\\xC5]/g, \"A\").replace(/[\\xC6]/g, \"AE\").replace(/[\\xC7]/g, \"C\").replace(/[\\xC8-\\xCB]/g, \"E\").replace(/[\\xCC-\\xCF]/g, \"I\").replace(/[\\xD0]/g, \"D\").replace(/[\\xD1]/g, \"N\").replace(/[\\xD2-\\xD6\\xD8]/g, \"O\").replace(/[\\xD9-\\xDC]/g, \"U\").replace(/[\\xDD]/g, \"Y\").replace(/[\\xDE]/g, \"P\").replace(/[\\xE0-\\xE5]/g, \"a\").replace(/[\\xE6]/g, \"ae\").replace(/[\\xE7]/g, \"c\").replace(/[\\xE8-\\xEB]/g, \"e\").replace(/[\\xEC-\\xEF]/g, \"i\").replace(/[\\xF1]/g, \"n\").replace(/[\\xF2-\\xF6\\xF8]/g, \"o\").replace(/[\\xF9-\\xFC]/g, \"u\").replace(/[\\xFE]/g, \"p\").replace(/[\\xFD\\xFF]/g, \"y\");\n    }\n    return str;\n  }\n}\nclass FilterUtils {\n  static filter(value, fields, filterValue, filterMatchMode, filterLocale) {\n    let filteredItems = [];\n    let filterText = ObjectUtils.removeAccents(filterValue).toLocaleLowerCase(filterLocale);\n    if (value) {\n      for (let item of value) {\n        for (let field of fields) {\n          let fieldValue = ObjectUtils.removeAccents(String(ObjectUtils.resolveFieldData(item, field))).toLocaleLowerCase(filterLocale);\n          if (FilterUtils[filterMatchMode](fieldValue, filterText, filterLocale)) {\n            filteredItems.push(item);\n            break;\n          }\n        }\n      }\n    }\n    return filteredItems;\n  }\n  static startsWith(value, filter, filterLocale) {\n    if (filter === undefined || filter === null || filter.trim() === '') {\n      return true;\n    }\n    if (value === undefined || value === null) {\n      return false;\n    }\n    let filterValue = ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);\n    let stringValue = ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale);\n    return stringValue.slice(0, filterValue.length) === filterValue;\n  }\n  static contains(value, filter, filterLocale) {\n    if (filter === undefined || filter === null || typeof filter === 'string' && filter.trim() === '') {\n      return true;\n    }\n    if (value === undefined || value === null) {\n      return false;\n    }\n    let filterValue = ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);\n    let stringValue = ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale);\n    return stringValue.indexOf(filterValue) !== -1;\n  }\n  static endsWith(value, filter, filterLocale) {\n    if (filter === undefined || filter === null || filter.trim() === '') {\n      return true;\n    }\n    if (value === undefined || value === null) {\n      return false;\n    }\n    let filterValue = ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);\n    let stringValue = ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale);\n    return stringValue.indexOf(filterValue, stringValue.length - filterValue.length) !== -1;\n  }\n  static equals(value, filter, filterLocale) {\n    if (filter === undefined || filter === null || typeof filter === 'string' && filter.trim() === '') {\n      return true;\n    }\n    if (value === undefined || value === null) {\n      return false;\n    }\n    if (value.getTime && filter.getTime) return value.getTime() === filter.getTime();else return ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale) == ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);\n  }\n  static notEquals(value, filter, filterLocale) {\n    if (filter === undefined || filter === null || typeof filter === 'string' && filter.trim() === '') {\n      return false;\n    }\n    if (value === undefined || value === null) {\n      return true;\n    }\n    if (value.getTime && filter.getTime) return value.getTime() !== filter.getTime();else return ObjectUtils.removeAccents(value.toString()).toLocaleLowerCase(filterLocale) != ObjectUtils.removeAccents(filter.toString()).toLocaleLowerCase(filterLocale);\n  }\n  static in(value, filter, filterLocale) {\n    if (filter === undefined || filter === null || filter.length === 0) {\n      return true;\n    }\n    if (value === undefined || value === null) {\n      return false;\n    }\n    for (let i = 0; i < filter.length; i++) {\n      if (ObjectUtils.equals(value, filter[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static lt(value, filter, filterLocale) {\n    if (filter === undefined || filter === null) {\n      return true;\n    }\n    if (value === undefined || value === null) {\n      return false;\n    }\n    if (value.getTime && filter.getTime) return value.getTime() < filter.getTime();else return value < filter;\n  }\n  static lte(value, filter, filterLocale) {\n    if (filter === undefined || filter === null) {\n      return true;\n    }\n    if (value === undefined || value === null) {\n      return false;\n    }\n    if (value.getTime && filter.getTime) return value.getTime() <= filter.getTime();else return value <= filter;\n  }\n  static gt(value, filter, filterLocale) {\n    if (filter === undefined || filter === null) {\n      return true;\n    }\n    if (value === undefined || value === null) {\n      return false;\n    }\n    if (value.getTime && filter.getTime) return value.getTime() > filter.getTime();else return value > filter;\n  }\n  static gte(value, filter, filterLocale) {\n    if (filter === undefined || filter === null) {\n      return true;\n    }\n    if (value === undefined || value === null) {\n      return false;\n    }\n    if (value.getTime && filter.getTime) return value.getTime() >= filter.getTime();else return value >= filter;\n  }\n}\nvar lastId = 0;\nfunction UniqueComponentId() {\n  let prefix = 'pr_id_';\n  lastId++;\n  return `${prefix}${lastId}`;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { FilterUtils, ObjectUtils, UniqueComponentId, lastId };\n//# sourceMappingURL=primeng-utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}