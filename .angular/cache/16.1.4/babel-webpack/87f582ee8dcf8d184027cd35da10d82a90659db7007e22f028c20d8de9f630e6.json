{"ast":null,"code":"import { EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, ElementRef, Renderer2, NgZone, ChangeDetectorRef, Input, ContentChild, ContentChildren, ViewChild, Output, NgModule } from '@angular/core';\nimport { animation, style, animate, trigger, transition, useAnimation } from '@angular/animations';\nimport { CommonModule } from '@angular/common';\nimport { DomHandler } from 'primeng/dom';\nimport { Header, Footer, PrimeTemplate, SharedModule } from 'primeng/api';\nimport { FocusTrapModule } from 'primeng/focustrap';\nimport { RippleModule } from 'primeng/ripple';\nlet idx = 0;\nconst showAnimation = animation([style({\n  transform: '{{transform}}',\n  opacity: 0\n}), animate('{{transition}}')]);\nconst hideAnimation = animation([animate('{{transition}}', style({\n  transform: '{{transform}}',\n  opacity: 0\n}))]);\nclass Dialog {\n  constructor(el, renderer, zone, cd) {\n    this.el = el;\n    this.renderer = renderer;\n    this.zone = zone;\n    this.cd = cd;\n    this.draggable = true;\n    this.resizable = true;\n    this.closeOnEscape = true;\n    this.closable = true;\n    this.showHeader = true;\n    this.blockScroll = false;\n    this.autoZIndex = true;\n    this.baseZIndex = 0;\n    this.minX = 0;\n    this.minY = 0;\n    this.focusOnShow = true;\n    this.keepInViewport = true;\n    this.focusTrap = true;\n    this.transitionOptions = '150ms cubic-bezier(0, 0, 0.2, 1)';\n    this.closeIcon = 'pi pi-times';\n    this.minimizeIcon = 'pi pi-window-minimize';\n    this.maximizeIcon = 'pi pi-window-maximize';\n    this.onShow = new EventEmitter();\n    this.onHide = new EventEmitter();\n    this.visibleChange = new EventEmitter();\n    this.onResizeInit = new EventEmitter();\n    this.onResizeEnd = new EventEmitter();\n    this.onDragEnd = new EventEmitter();\n    this.id = `p-dialog-${idx++}`;\n    this._style = {};\n    this._position = \"center\";\n    this.transformOptions = \"scale(0.7)\";\n  }\n  get positionLeft() {\n    return 0;\n  }\n  set positionLeft(_positionLeft) {\n    console.log(\"positionLeft property is deprecated.\");\n  }\n  get positionTop() {\n    return 0;\n  }\n  set positionTop(_positionTop) {\n    console.log(\"positionTop property is deprecated.\");\n  }\n  get responsive() {\n    return false;\n  }\n  set responsive(_responsive) {\n    console.log(\"Responsive property is deprecated.\");\n  }\n  get breakpoint() {\n    return 649;\n  }\n  set breakpoint(_breakpoint) {\n    console.log(\"Breakpoint property is not utilized and deprecated, use CSS media queries instead.\");\n  }\n  ngAfterContentInit() {\n    this.templates.forEach(item => {\n      switch (item.getType()) {\n        case 'header':\n          this.headerTemplate = item.template;\n          break;\n        case 'content':\n          this.contentTemplate = item.template;\n          break;\n        case 'footer':\n          this.footerTemplate = item.template;\n          break;\n        default:\n          this.contentTemplate = item.template;\n          break;\n      }\n    });\n  }\n  get visible() {\n    return this._visible;\n  }\n  set visible(value) {\n    this._visible = value;\n    if (this._visible && !this.maskVisible) {\n      this.maskVisible = true;\n    }\n  }\n  get style() {\n    return this._style;\n  }\n  set style(value) {\n    if (value) {\n      this._style = Object.assign({}, value);\n      this.originalStyle = value;\n    }\n  }\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    this._position = value;\n    switch (value) {\n      case 'topleft':\n      case 'bottomleft':\n      case 'left':\n        this.transformOptions = \"translate3d(-100%, 0px, 0px)\";\n        break;\n      case 'topright':\n      case 'bottomright':\n      case 'right':\n        this.transformOptions = \"translate3d(100%, 0px, 0px)\";\n        break;\n      case 'bottom':\n        this.transformOptions = \"translate3d(0px, 100%, 0px)\";\n        break;\n      case 'top':\n        this.transformOptions = \"translate3d(0px, -100%, 0px)\";\n        break;\n      default:\n        this.transformOptions = \"scale(0.7)\";\n        break;\n    }\n  }\n  focus() {\n    let focusable = DomHandler.findSingle(this.container, '[autofocus]');\n    if (focusable) {\n      this.zone.runOutsideAngular(() => {\n        setTimeout(() => focusable.focus(), 5);\n      });\n    }\n  }\n  close(event) {\n    this.visibleChange.emit(false);\n    event.preventDefault();\n  }\n  enableModality() {\n    if (this.closable && this.dismissableMask) {\n      this.maskClickListener = this.renderer.listen(this.wrapper, 'click', event => {\n        if (this.wrapper && this.wrapper.isSameNode(event.target)) {\n          this.close(event);\n        }\n      });\n    }\n    if (this.modal) {\n      DomHandler.addClass(document.body, 'p-overflow-hidden');\n    }\n  }\n  disableModality() {\n    if (this.wrapper) {\n      if (this.dismissableMask) {\n        this.unbindMaskClickListener();\n      }\n      if (this.modal) {\n        DomHandler.removeClass(document.body, 'p-overflow-hidden');\n      }\n      if (!this.cd.destroyed) {\n        this.cd.detectChanges();\n      }\n    }\n  }\n  maximize() {\n    this.maximized = !this.maximized;\n    if (!this.modal && !this.blockScroll) {\n      if (this.maximized) DomHandler.addClass(document.body, 'p-overflow-hidden');else DomHandler.removeClass(document.body, 'p-overflow-hidden');\n    }\n  }\n  unbindMaskClickListener() {\n    if (this.maskClickListener) {\n      this.maskClickListener();\n      this.maskClickListener = null;\n    }\n  }\n  moveOnTop() {\n    if (this.autoZIndex) {\n      this.container.style.zIndex = String(this.baseZIndex + ++DomHandler.zindex);\n      this.wrapper.style.zIndex = String(this.baseZIndex + (DomHandler.zindex - 1));\n    }\n  }\n  initDrag(event) {\n    if (DomHandler.hasClass(event.target, 'p-dialog-header-icon') || DomHandler.hasClass(event.target.parentElement, 'p-dialog-header-icon')) {\n      return;\n    }\n    if (this.draggable) {\n      this.dragging = true;\n      this.lastPageX = event.pageX;\n      this.lastPageY = event.pageY;\n      this.container.style.margin = '0';\n      DomHandler.addClass(document.body, 'p-unselectable-text');\n    }\n  }\n  onKeydown(event) {\n    if (this.focusTrap) {\n      if (event.which === 9) {\n        event.preventDefault();\n        let focusableElements = DomHandler.getFocusableElements(this.container);\n        if (focusableElements && focusableElements.length > 0) {\n          if (!focusableElements[0].ownerDocument.activeElement) {\n            focusableElements[0].focus();\n          } else {\n            let focusedIndex = focusableElements.indexOf(focusableElements[0].ownerDocument.activeElement);\n            if (event.shiftKey) {\n              if (focusedIndex == -1 || focusedIndex === 0) focusableElements[focusableElements.length - 1].focus();else focusableElements[focusedIndex - 1].focus();\n            } else {\n              if (focusedIndex == -1 || focusedIndex === focusableElements.length - 1) focusableElements[0].focus();else focusableElements[focusedIndex + 1].focus();\n            }\n          }\n        }\n      }\n    }\n  }\n  onDrag(event) {\n    if (this.dragging) {\n      let containerWidth = DomHandler.getOuterWidth(this.container);\n      let containerHeight = DomHandler.getOuterHeight(this.container);\n      let deltaX = event.pageX - this.lastPageX;\n      let deltaY = event.pageY - this.lastPageY;\n      let offset = DomHandler.getOffset(this.container);\n      let leftPos = offset.left + deltaX;\n      let topPos = offset.top + deltaY;\n      let viewport = DomHandler.getViewport();\n      this.container.style.position = 'fixed';\n      if (this.keepInViewport) {\n        if (leftPos >= this.minX && leftPos + containerWidth < viewport.width) {\n          this._style.left = leftPos + 'px';\n          this.lastPageX = event.pageX;\n          this.container.style.left = leftPos + 'px';\n        }\n        if (topPos >= this.minY && topPos + containerHeight < viewport.height) {\n          this._style.top = topPos + 'px';\n          this.lastPageY = event.pageY;\n          this.container.style.top = topPos + 'px';\n        }\n      } else {\n        this.lastPageX = event.pageX;\n        this.container.style.left = leftPos + 'px';\n        this.lastPageY = event.pageY;\n        this.container.style.top = topPos + 'px';\n      }\n    }\n  }\n  endDrag(event) {\n    if (this.dragging) {\n      this.dragging = false;\n      DomHandler.removeClass(document.body, 'p-unselectable-text');\n      this.cd.detectChanges();\n      this.onDragEnd.emit(event);\n    }\n  }\n  resetPosition() {\n    this.container.style.position = '';\n    this.container.style.left = '';\n    this.container.style.top = '';\n    this.container.style.margin = '';\n  }\n  //backward compatibility\n  center() {\n    this.resetPosition();\n  }\n  initResize(event) {\n    if (this.resizable) {\n      this.resizing = true;\n      this.lastPageX = event.pageX;\n      this.lastPageY = event.pageY;\n      DomHandler.addClass(document.body, 'p-unselectable-text');\n      this.onResizeInit.emit(event);\n    }\n  }\n  onResize(event) {\n    if (this.resizing) {\n      let deltaX = event.pageX - this.lastPageX;\n      let deltaY = event.pageY - this.lastPageY;\n      let containerWidth = DomHandler.getOuterWidth(this.container);\n      let containerHeight = DomHandler.getOuterHeight(this.container);\n      let contentHeight = DomHandler.getOuterHeight(this.contentViewChild.nativeElement);\n      let newWidth = containerWidth + deltaX;\n      let newHeight = containerHeight + deltaY;\n      let minWidth = this.container.style.minWidth;\n      let minHeight = this.container.style.minHeight;\n      let offset = DomHandler.getOffset(this.container);\n      let viewport = DomHandler.getViewport();\n      let hasBeenDragged = !parseInt(this.container.style.top) || !parseInt(this.container.style.left);\n      if (hasBeenDragged) {\n        newWidth += deltaX;\n        newHeight += deltaY;\n      }\n      if ((!minWidth || newWidth > parseInt(minWidth)) && offset.left + newWidth < viewport.width) {\n        this._style.width = newWidth + 'px';\n        this.container.style.width = this._style.width;\n      }\n      if ((!minHeight || newHeight > parseInt(minHeight)) && offset.top + newHeight < viewport.height) {\n        this.contentViewChild.nativeElement.style.height = contentHeight + newHeight - containerHeight + 'px';\n        if (this._style.height) {\n          this._style.height = newHeight + 'px';\n          this.container.style.height = this._style.height;\n        }\n      }\n      this.lastPageX = event.pageX;\n      this.lastPageY = event.pageY;\n    }\n  }\n  resizeEnd(event) {\n    if (this.resizing) {\n      this.resizing = false;\n      DomHandler.removeClass(document.body, 'p-unselectable-text');\n      this.onResizeEnd.emit(event);\n    }\n  }\n  bindGlobalListeners() {\n    if (this.draggable) {\n      this.bindDocumentDragListener();\n      this.bindDocumentDragEndListener();\n    }\n    if (this.resizable) {\n      this.bindDocumentResizeListeners();\n    }\n    if (this.closeOnEscape && this.closable) {\n      this.bindDocumentEscapeListener();\n    }\n  }\n  unbindGlobalListeners() {\n    this.unbindDocumentDragListener();\n    this.unbindDocumentDragEndListener();\n    this.unbindDocumentResizeListeners();\n    this.unbindDocumentEscapeListener();\n  }\n  bindDocumentDragListener() {\n    this.zone.runOutsideAngular(() => {\n      this.documentDragListener = this.onDrag.bind(this);\n      window.document.addEventListener('mousemove', this.documentDragListener);\n    });\n  }\n  unbindDocumentDragListener() {\n    if (this.documentDragListener) {\n      window.document.removeEventListener('mousemove', this.documentDragListener);\n      this.documentDragListener = null;\n    }\n  }\n  bindDocumentDragEndListener() {\n    this.zone.runOutsideAngular(() => {\n      this.documentDragEndListener = this.endDrag.bind(this);\n      window.document.addEventListener('mouseup', this.documentDragEndListener);\n    });\n  }\n  unbindDocumentDragEndListener() {\n    if (this.documentDragEndListener) {\n      window.document.removeEventListener('mouseup', this.documentDragEndListener);\n      this.documentDragEndListener = null;\n    }\n  }\n  bindDocumentResizeListeners() {\n    this.zone.runOutsideAngular(() => {\n      this.documentResizeListener = this.onResize.bind(this);\n      this.documentResizeEndListener = this.resizeEnd.bind(this);\n      window.document.addEventListener('mousemove', this.documentResizeListener);\n      window.document.addEventListener('mouseup', this.documentResizeEndListener);\n    });\n  }\n  unbindDocumentResizeListeners() {\n    if (this.documentResizeListener && this.documentResizeEndListener) {\n      window.document.removeEventListener('mousemove', this.documentResizeListener);\n      window.document.removeEventListener('mouseup', this.documentResizeEndListener);\n      this.documentResizeListener = null;\n      this.documentResizeEndListener = null;\n    }\n  }\n  bindDocumentEscapeListener() {\n    const documentTarget = this.el ? this.el.nativeElement.ownerDocument : 'document';\n    this.documentEscapeListener = this.renderer.listen(documentTarget, 'keydown', event => {\n      if (event.which == 27) {\n        if (parseInt(this.container.style.zIndex) === DomHandler.zindex + this.baseZIndex) {\n          this.close(event);\n        }\n      }\n    });\n  }\n  unbindDocumentEscapeListener() {\n    if (this.documentEscapeListener) {\n      this.documentEscapeListener();\n      this.documentEscapeListener = null;\n    }\n  }\n  appendContainer() {\n    if (this.appendTo) {\n      if (this.appendTo === 'body') document.body.appendChild(this.wrapper);else DomHandler.appendChild(this.wrapper, this.appendTo);\n    }\n  }\n  restoreAppend() {\n    if (this.container && this.appendTo) {\n      this.el.nativeElement.appendChild(this.wrapper);\n    }\n  }\n  onAnimationStart(event) {\n    switch (event.toState) {\n      case 'visible':\n        this.container = event.element;\n        this.wrapper = this.container.parentElement;\n        this.onShow.emit({});\n        this.appendContainer();\n        this.moveOnTop();\n        this.bindGlobalListeners();\n        if (this.modal) {\n          this.enableModality();\n        }\n        if (!this.modal && this.blockScroll) {\n          DomHandler.addClass(document.body, 'p-overflow-hidden');\n        }\n        if (this.focusOnShow) {\n          this.focus();\n        }\n        break;\n    }\n  }\n  onAnimationEnd(event) {\n    switch (event.toState) {\n      case 'void':\n        this.onContainerDestroy();\n        this.onHide.emit({});\n        break;\n    }\n  }\n  onContainerDestroy() {\n    this.unbindGlobalListeners();\n    this.dragging = false;\n    this.maskVisible = false;\n    if (this.maximized) {\n      DomHandler.removeClass(document.body, 'p-overflow-hidden');\n      this.maximized = false;\n    }\n    if (this.modal) {\n      this.disableModality();\n    }\n    if (this.blockScroll) {\n      DomHandler.removeClass(document.body, 'p-overflow-hidden');\n    }\n    this.container = null;\n    this.wrapper = null;\n    this._style = this.originalStyle ? Object.assign({}, this.originalStyle) : {};\n  }\n  ngOnDestroy() {\n    if (this.container) {\n      this.restoreAppend();\n      this.onContainerDestroy();\n    }\n  }\n}\nclass DialogModule {}\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Dialog, DialogModule };\n//# sourceMappingURL=primeng-dialog.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}